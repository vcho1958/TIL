# Why Prisma?

프리즈마를 배워야할 이유와 ORM, SQL query 빌더 모듈같은 DB툴과의 차이점들입니다.

관계형 DB들을 운용하는 것은 앱 개발의 중요한 병목지점입니다. SQL 쿼리를 디버깅하거나 복잡한 ORM 객체들은 종종 개발시간을 소모하게 합니다.

프리즈마는 DB쿼리를 깔끔하고 type safe하게 작성할 수 있도록 구 자바스크립트 객체로 반환하게 하므로써 간편하게 쿼리를 짤 수 있게 합니다.

## [](https://www.prisma.io/docs/concepts/overview/why-prisma#tldr)TLDR

프리즈마의 최종 목표는 앱 개발자들이 DB를 다룰 때 더 생산성있게 만드는 것입니다.

- 관계형 데이터를 맵핑하는 것 대신에 JSON 객체를 생각합니다.
- 클래스를 통해 쿼리하지 않음으로써 복잡한 모델 클래스(DAO)가 없습니다.
- DB와 앱 모델들의 신뢰성을 위해 쿼리를 날릴 때 모든 모델에서 단일 커넥션 객체를 사용합니다.
- 적절한 문법 제약사항으로 실수나 안티 패턴을 방지합니다.
- 추상화를 통해 올바른 구현을 쉽게 할 수 있게 합니다.
- type safe한 DB쿼리는 컴파일 타임을 줄여줍니다.
- 사전 작업이 적어 개발자들이 서비스 로직 개발에 집중할 수 있습니다.
- 라이브러리 주석이 상세하게 달려있고 VSCode에서 자동완성을 지원해 공식문서를 참고할 일이 적습니다.

다음 부분은 기존 DB툴들과 Prisma의 차이점입니다.

## [](https://www.prisma.io/docs/concepts/overview/why-prisma#problems-with-sql-orms-and-other-database-tools) SQL, ORM 및 다른 라이브러리들의 문제점

Node.js와 TypeScript의 생테계에 현재 존재하는 라이브러리들의 큰 문제는 생산성과 난이도의 트레이드오프입니다. 

[![Productivity vs Control in ORMs, SQL query builders, and SQL](https://res.cloudinary.com/prismaio/image/upload/v1628761152/docs/ruJmTac.png)](https://res.cloudinary.com/prismaio/image/upload/v1628761152/docs/ruJmTac.png)

### [](https://www.prisma.io/docs/concepts/overview/why-prisma#raw-sql-full-control-low-productivity) 로우 쿼리: 좋은 커스터마이징, 낮은 생산성

pg 혹은 mysql 라이브러리의 로우 쿼리는 DB연산을 커스터마이징하는데 좋습니다. 하지만 쿼리문을 DB에 보내는 데 드는 생산성 저하는 수동 커넥션 조절(끊고 재연결하는 타이밍), 반복적인 사전작업 등의 심각하고 많은 오버헤드를 가져옵니다. 

이 접근법의 더 큰 문제는 당신은 쿼리 반환에 대하여 어떤 타입이 안전한지 체크할 수 없다는 것입니다. 당연히 당신은 수동으로 타입을 지정할 수 있지만 이것은 많은 공수가 들 뿐더러 DB스키마가 변경되거나 쿼리문이 변경될 경우 동기화를 위해 많은 양의 작업을 요구합니다.

게다가 SQL 쿼리를 직접 작성하는 것은 IDE의 도움을 받을 수 없다는 단점도 있습니다.

### [](https://www.prisma.io/docs/concepts/overview/why-prisma#sql-query-builders-high-control-medium-productivity)SQL 쿼리 빌더: 로우쿼리보다는 낮은 커스텀, 중간 생산성

더 나은 생산성을 제공하고 그나마 높은 커스텀 기능을 위한 솔루션은 SQL 쿼리 빌더를 사용하는 것입니다.(e.g. [knex.js](https://knexjs.org/)) 이 종류의 라이브러리는 SQL작성을 위해 프로그래밍적인 추상화를 제공해줍니다.

SQL쿼리빌더의 큰 약점은 앱 개발자들이 SQL의 결과에 대한 데이터를 지속적으로 생각해야하는 것입니다. 이것은 신경이 많이 쓰이며 관계형 데이터를 클래스화 하는 데에 큰 비용을 쓰게 만듭니다. 또 다른 이슈는 쿼리빌더가 당신이 의도한 대로 쿼리문을 생성하지 않을 확률이 있다는 것입니다.

### [](https://www.prisma.io/docs/concepts/overview/why-prisma#orms-less-control-better-productivity)ORM: 가장 좋지 않은 커스텀, 높은 생산성

ORM의 추상화는 당신이 애플리케이션 모델을 클래스로 정의하게 하고 쿼리문을 생각하지 않아도 괜찮게하며 이 클래스는 DB 테이블에 매핑됩니다.
> (ORMs) 은 개발자들이 쿼리문보다는 친숙한 클래스와 DB모델, 관계를 매핑해줍니다. 클래스는 프로그램에서 한가지 객체의 상태를 캡슐화하는 것에 용이하고 DB는 전체적인 데이터 셋의 제약사항과 효과적이고 빠른 접근 패턴을 위해 관계를 사용합니다. 
> [The Troublesome Active Record Pattern, Cal Paterson (2020)](https://calpaterson.com/activerecord.html)

당신은 매핑된 모델 클래스의 인스턴스의 메소드를 호출함으로써 DB 데이터를 읽고 쓸 수 있습니다.

이것은 더 편리하고 개발자들이 DB의 데이터를 생각할 때 클래스로 생각하게끔 해줍니다.

그럼 무엇이 문제일까?

> ORM은 개발을 시작하기위해서 높은 장벽이 있습니다. 시간이 지날수록 복잡해지고, 유저가 커밋하기까지 긴 커넥션을 유지해야하며 커넥션의 종료지점이 명확하지 않습니다. 완벽한 쿼리를 설계할 수도 없고 세밀하게 제어할 수 있는 방법이 없습니다
> 
> [The Vietnam of Computer Science, Ted Neward (2006)](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/)

앱개발자라면 당신의 데이터를 생각할 때 객체로 생각할 수 있습니다. SQL의 데이터를 위한 클래스는 테이블로 나타날 수 있습니다.

데이타 표현의 두가지 다른 표현은 종종 객체와 관계형 데이터의 미스매치로 이어집니다. [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). 

객체와 관계형 정보들의 미스매치는 많은 개발자들이 전통적인 ORM을 이용하기 싫어하는 이유입니다.

데이터들이 어떻게 조직하고 관계들을 다루는 것은 다음과 같이 볼 수 있습니다: 

- 관계형 DB: 데이터들이 전형적으로 정규화되어있고 FK를 통해 엔티티들을 연결합니다. 엔티티들은 다른 엔티티들을 명백하게 구분해 조인할수 있는 요소가 필요합니다.
- 객체지향: 객체들은 중첩하여 깊이를 가질수있는 구조이기 때문에 참조연산자(.)을 통해 관계들을 간편하게 참조할 수 있습니다.



This alludes to one of the major pitfalls with ORMs: While they make it _seem_ that you can simply traverse relationships using familiar dot notation, under the hood the ORM generates SQL JOINs which are expensive and have the potential to drastically slow down your application (one symptom of this is the [n+1 problem](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)).

To conclude: The appeal of ORMs is the premise of abstracting away the relational model and thinking about your data purely in terms of objects. While the premise is great, it's based on the wrong assumption that relational data can easily be mapped to objects which leads to lots of complications and pitfalls.

## [](https://www.prisma.io/docs/concepts/overview/why-prisma#application-developers-should-care-about-data--not-sql)Application developers should care about data – not SQL

Despite being developed in the 1970s(!), SQL has stood the test of time in an impressive manner. However, with the advancement and modernization of developers tools, it's worth asking if SQL really is the best abstraction for application developers to work with?

After all, **developers should only care about the _data_ they need to implement a feature** and not spend time figuring out complicated SQL queries or massaging query results to fit their needs.

There's another argument to be made against SQL in application development. The power of SQL can be a blessing if you know exactly what you're doing, but its complexity can be a curse. There are a lot of [anti-patterns](https://www.slideshare.net/billkarwin/sql-antipatterns-strike-back) and pitfalls that even experienced SQL users struggle to anticipate, often at the cost of performance and hours of debugging time.

Developers should be able to ask for the data they need instead of having to worry about "doing the right thing" in their SQL queries. They should be using an abstraction that makes the right decisions for them. This can mean that the abstraction imposes certain "healthy" constraints that prevent developers from making mistakes.

## [](https://www.prisma.io/docs/concepts/overview/why-prisma#prisma-makes-developers-productive)Prisma makes developers productive

Prisma's main goal is to make application developers more productive when working with databases. Considering the tradeoff between productivity and control again, this is how Prisma fits in:

[![Prisma makes developers productive](https://res.cloudinary.com/prismaio/image/upload/v1628761152/docs/38uWKzW.png)](https://res.cloudinary.com/prismaio/image/upload/v1628761152/docs/38uWKzW.png)