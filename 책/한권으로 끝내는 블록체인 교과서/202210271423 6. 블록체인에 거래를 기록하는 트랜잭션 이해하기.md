# 트랜잭션 ID
거래내용, 타임스탬프, 전자서명으로 이루어진 트랜잭션 파일
을 해시한 것이 트랜잭션 ID입니다.

금액 트랜잭션에 메세지를 추가할 수 있는 기능을 활용하여 확장할 수 있다.

## 복식 부기 원장형식
송신자의 INPUT과 수신자의 OUTPUT 합계가 같아야한다.

블록체인의 UTXO는 잔액의 개념을 포함해야한다.

비트코인의 경우  UTXO >= INPUT>=OUTPUT
채굴자에게 수수료로 지급할 암호화폐 금액을 뺴기 때문에 수수료가 차감된다.

수수료는 자유롭게 정할 수 있다. 그러나 실수로 기입하면 블록체인은 수정할 수 없다.
수수료가 너무 낮으면 블로체인 네트워크에서 거부당할 수 있다.

트랜잭션이 채굴에 비해 너무 많아 수수료가 수천원까지 오른적이 있었지만 안정됐다

# 채굴량
블록의 첫 트랜잭션(코인베이스 트랜잭션)에 발행된 암호화폐의 양이 적힌다.
해당 암호화폐는 화폐마다 다르지만 이후 블록이 몇개이상 쌓여야(변조가 힘들어져야) 사용이 가능하다.

# 합의하는 방법
버킷릴레이 방식으로 이웃 노드에 배포와 복사를 반복해 배포됩니다.
채굴자가 승인 시에 트랜잭션이 블록에 포함된다.

만약 분기가 다른분기로 정해지더라도 트랜잭션은 두곳에 모두 포함되므로 피해가 적으나
채굴자는 지급 여부가 정해지니 더 중요하다.

프라이빗 블록체인은 분기가 없는 구현도 있다.


블록체인에서는 각각의 노드의 성능차이도 있고 따라서 트랜잭션의 순서가 보장되지 않는다.
따라서 선착순으로 처리해야할 상황이 오면 하이퍼레저 패브릭이라는 블록체인 시스템이 있으며
카프카 라는 메시지 큐와 연결해 트랜잭션의 처리 순서를 보장합니다.

혹은 타임스탬프를 통해 순서를 정해도 된다.

## 트랜잭션의 구조
- 버전 정보
- 인풋
	- 입력 수
	- UTXO를 포함한 트랜잭션 ID : 거래내용, 타임스탬프, 전자서명
	- UTXO의 인덱스(몇번 째 OUTPUT을 사용하는가)
	- 송신자의 전자 서명과 공개 키
- 아웃풋
	- 출력 수
	- 송금하는 암호화폐 금액
	- 송금자 지갑 주소
	- 반환하는 암호화폐 금액
	- 암호화폐를 반환할 지갑 주소
각 트랜잭션을 순차탐색하기보다는 해쉬테이블로 관리하기 위해 키-값 스토리지
Key-Value Storage, KVS에 저장합니다.

KVS는 이진 트리, 머클트리라고도 하며 머클 루트를 해시 함수에 넣어 얻은 값은 
블록헤더에 영구적으로 기록됩니다.
루트는 각 트랜잭션 쌍들을 해쉬하고 더하고를 반복한 결과이며 자식 들은 그 절반씩이 됩니다.

### 블록 헤더
- 버전 정보
- 이전 블록헤더의 해시값
- 머클 루트 해시값
- 생성 타임스탬프
- 채굴할 때의 난이도
- 채굴할 때 주어진 논스

### 트랜잭션
- 해당 블록에 포함된 트랜잭션 수
- 서명된 트랜잭션 데이터

하나라도 변조가 발생하면 해당 블록 이후 해시값이 모두 일치하지 않게됩니다.
고의로 이상한 트랜잭션을 넣는것은 무수히 많은 연산을하더라도 불가능 합니다.

블록은 위조를 방지하기 위함입니다.


## 복사해도 괜찮은 암호화폐
암호화폐는 수신자의 공개키를 주소로 보냅니다.
따라서 트랜잭션 자체에 목적지가 적혀있고 UTXO로 잔액을 유추하기 때문에
해당 트랜잭션을 복사하여 다른사람에게 보내더라도 원래 수신자가 아니면 해당 화폐와 일치하는 비밀 키가 없기 때문에 전자 서명을 할 수 없습니다.

오프라인 가게가 만약 처리되지 않은 것도 트랜잭션이 발송됐을 때 처리하는 제로 컨펌을 하지 않을 시
만약 해당 트랜잭션이 거부되어 다시 발송해서 풀에 쌓일경우 가게에서 취소요청을 했을 때 이중 지급이 될 수 있음.

## 분산 원장 기술에 적용한 이중 지급 해결 방법
코다라는 분산원장 기술은 UTXO를 사용할 때의 이중 지급 문제를 해결하려고 분산단일성 서비스를 적용했다. 지금까지 사용하지 않은 UTXO라는 것을 상대방에게 알려 취소된 트랜잭션에 대하여 이중지급을 하지 않게 해줍니다.
