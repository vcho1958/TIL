# 1. 경청하기

자신이 문제를 잘 이해했는지 확인하고 독특한 정보를 기억해 두어야 한다. 제공되는 정보는 모두 이유가 있다.

-   정렬된 배열 : 데이터 정렬의 유무는 알고리즘을 설계할 때 아주 다른 접근을 요한다.
-   서버에서 호출이 잦은: 무엇인가가 반복적으로 실행되는 경우 적당한 계산 결과를 예측하여 미리 구해(캐싱)놓아도 된다는 의미다.

중간에 막혔거나 최적화를 계속해서 하는 상태라면 주어진 정보를 모두 사용하고 있는지 확인해야한다.

화이트보드에 정보를 써 놓는 것도 유용한 방법

# 2. 예제를 직접 그려보기

명확한 예제: 문제에 맞는 실제 숫자와 문자열을 입력으로 사용

충분히 큰 예제: 패턴을 찾을 수 있을 만큼 로직이 반복될 정도의 입력을 가지고 예제를 만든다.

특별한 예제를 지양하라: 엣지케이스 혹은 계산이 편하도록 틀을 만들지 마라. 균형잡힌 트리처럼 특수한 예제는 전체 상황에서 매우 희귀한 상황이다.

# 3. 무식한 방법으로 일단 해보기

2번보다 먼저 해보아도 된다. 시간복잡도처럼 부수적인 것들은 제외하고 로직을 설계

의외로 그리디한 해결방법이 될 수도 있고 다른 로직을 고민하다가 면접관들이 아예 시도도 못하고 있다고 생각할 수도 있다.

느린 알고리즘이더라도 면접관과 토론할 거리를 만드는 게 상황을 더 좋게 만들 수 있다.

또한 이 과정이 문제 해결방법의 갈피를 잡을 수 있게 해줄 수 있다.

# 4. 최적화

1.  정렬된 자료인지, 활용방안이 있는지
2.  다른 예제를 만들어서 테스트해보며 새로운 패턴 찾기를 시도해보자.
3.  잘못된 방식으로 풀고 해결방법을 찾는다.
    1.  어떤 집합에서 임의의 원소를 동일한 확률로 선택해야하는 문제에서
    2.  임의의 원소를 비슷비슷하게라도 선택되게한다.
    3.  이 과정을 통해 확률을 동일하게 할 수는 없는지에 대하여 질문을 던질 수 있게 된다.
4.  시간복잡도를 위해서 공간복잡도를 조금 포기하자
    1.  해쉬테이블, 메모이제이션이 그 예시이다.
5.  정보를 미리 계산해두자.
    1.  정렬 혹은 기타 전처리를 통해 알고리즘 중간에서 하는 동작을 감소시킬 수 있는 방법을 찾아보자.
6.  가능한 최선의 수행시간(BCR)이 무엇인지 생각해보자.

# 5. 검토하기

의사코드를 통해 빈 과정은 없는지 다시 확인한다.

어떤 변수를 사용할 것인지 값을 변화시키는 시점 파악.

# 6. 코드 작성하기

코드가 기울어지지 않도록 조심하자.

배열 초기 값 대입등은 모듈화된 함수가 있다고 가정하고 사용하자. 추후 필요할 때 내용을 적으면 된다.

코드에 todo로 어떤 테스트를 할 것인지 작성하고 설명하자.

어떤 특정한 역할을 하는 클래스가 있다고 생각하고 작성하자.

반복문도 i, j 보다는 startOfRow라던지 의미가 있는 이름으로 순환문을 작성하자.

-   코드가 길어질수록 본인이 어떤 의미로 사용했는지 파악이 어려워진다.
-   너무 길어도 시간이 지체되므로 처음에만 길게 작성하고 sr처럼 줄여사용하겠다고 면접관들에게 말한다.

만약 중간에 헷갈리는 등 리팩토링을 해야할 필요가 있을 때 면접관들에게 설명 후 시간을 들일 필요가 있는지 힌트를 얻는다.

# 7. 테스트

테스트 없이 제출하지 마라.

## 개념적 테스트

한줄 한줄 트래킹해가며 동작을 예상하며 면접관에게 설명하듯이 진행한다.

## 평소와 다른 동작 확인

예를 들어 length-1이 아니라 -2인 경우, i가 1부터 시작하는 루프의 경우 이유를 다시 파악해야한다.

## 버그가 자주 발생하는 부분

문제를 푼 경험을 기반으로 버그가 많이 발생했거나 생소했던 로직 위주로 확인하자.

null이 발생할 수 있는 부분이나 절삭오류, 오버플로우, 연결리스트 순회할 때 시작 끝을 경유하는지 확인하자.

## 작은 것부터 테스트

이제 실제 데이터를 가지고 해당 포인트들을 테스트해보자 원소는 적당한 길이 3~4개(엣지케이스가 나올만한 크기)

배열이 작을수록 원인 분석에 유리하다.

### BUD를 찾자

병목현상, 불필요한 작업, 중복되는 작업을 찾자.

1.  병목현상
    1.  작은 부분보다 시간복잡도가 더 큰 부분을 최적화하자
    2.  검색, 정렬처럼 무거운 연산(NlogN)을 중첩해서 여러번 하는 등 불필요한 과정을 제거하자.
        1.  어떤 수로 이루어진 배열이 있을 때 k 간격인 쌍이 몇개 있는지 세시오.
            1.  이 문제는 두번째원소를 찾을 때 문제가 된다.
            2.  순차 탐색을 할경우 n제곱이 되나.
            3.  사전에 정렬을 하고 이진탐색을 할 경우 정렬NlogN + 원소마다N*이진 탐색logN으로 NlogN으로 줄일 수 있다.
            4.  이 때 탐색하는 부분을 최적화하더라도 정렬자체가 지배하기 때문에 비용은 줄지않는다.
            5.  따라서 정렬을 하지 않는 방법을 생각해야한다.
            6.  이 때 해시테이블을 사용하면 기입하는 데 N + 찾을 때 1로 최적화할 수 있다.
2.  불필요한 작업
    1.  a,b,c,d가 있을 때 a^3+b^3=c^3+d^3을 만족하는 쌍을 출력하시오.
        1.  for문을 4중첩하면 무식하게 풀 수 있다.
            1.  d를 찾으면 탈출하여 약간이지만 시간을 줄일 수 있다.
        2.  c까지만 구하고 d는 공식으로 풀어 N^4에서 N^3으로 줄일 수 있다.
3.  중복되는 작업